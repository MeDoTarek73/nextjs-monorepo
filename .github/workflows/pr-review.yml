name: Deploy PR Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: read
  packages: write
  issues: write
  pull-requests: write

jobs:
  build-frontend:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      namespace: ${{ steps.build.outputs.namespace }}

    steps:
      - name: Check branch prefix
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          if [[ $BRANCH_NAME != feature/* ]]; then
            echo "‚ùå Not a feature branch ($BRANCH_NAME)"
            exit 0
          fi

      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push Frontend image
        id: build
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          IMAGE_TAG=${BRANCH_NAME#feature/}
          IMAGE_TAG=$(echo $IMAGE_TAG | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="ghcr.io/$REPO_NAME:$IMAGE_TAG"

          echo "üõ†Ô∏è Building Frontend image $IMAGE_NAME"
          docker build -t $IMAGE_NAME -f apps/nextjs-app/Dockerfile .
          docker push $IMAGE_NAME

          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "namespace=$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-frontend:
    needs: build-frontend
    runs-on: ubuntu-latest

    steps:
      - name: Set up kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 --decode > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config get-contexts

      - name: Prepare namespace and GHCR access
        run: |
          export KUBECONFIG=kubeconfig
          NS=${{ needs.build-frontend.outputs.namespace }}

          echo "üß© Creating namespace $NS"
          kubectl create namespace $NS --dry-run=client -o yaml | kubectl apply -f -

          echo "üîê Creating/Updating GHCR secret in namespace"
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.REGISTRY_PASSWORD }} \
            --docker-email=${{ github.actor }}@users.noreply.github.com \
            -n $NS \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "ü™™ Patching default ServiceAccount in namespace $NS"
          kubectl patch serviceaccount default -n $NS \
            -p '{"imagePullSecrets": [{"name": "ghcr-secret"}]}'

      - name: Deploy Frontend Service
        run: |
          export KUBECONFIG=kubeconfig
          NS=${{ needs.build-frontend.outputs.namespace }}
          IMAGE_TAG=${{ needs.build-frontend.outputs.image-tag }}

          echo "üöÄ Deploying Frontend Service"

          # Force delete existing deployment and pods
          kubectl delete deployment frontend-application -n $NS --ignore-not-found=true
          kubectl delete pods -l app=frontend-application -n $NS --ignore-not-found=true

          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-application
            namespace: $NS
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: frontend-application
            template:
              metadata:
                labels:
                  app: frontend-application
              spec:
                containers:
                - name: frontend-application
                  image: ghcr.io/medotarek73/nextjs-monorepo:$IMAGE_TAG
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: API_URL
                    value: "http://backend-service:8080"
                imagePullSecrets:
                - name: ghcr-secret
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: frontend-application
            namespace: $NS
          spec:
            selector:
              app: frontend-application
            ports:
            - port: 3000
              targetPort: 3000
          EOF

      - name: Create Ingress
        run: |
          export KUBECONFIG=kubeconfig
          NS=${{ needs.build-frontend.outputs.namespace }}

          HOST="$NS.semibots.com"
          echo "üåê Creating ingress for $HOST"

          kubectl apply -f - <<EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${NS}-ingress
            namespace: $NS
            annotations:
              cert-manager.io/cluster-issuer: "letsencrypt-dns"
          spec:
            ingressClassName: traefik
            tls:
            - hosts:
              - $HOST
              secretName: ${NS}-tls
            rules:
            - host: $HOST
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-application
                      port:
                        number: 3000
          EOF

          echo "‚úÖ Frontend deployed successfully at https://$HOST"

  deploy-backend:
    needs: build-frontend
    runs-on: ubuntu-latest
    outputs:
      backend-image-tag: ${{ steps.set-output.outputs.backend-image-tag }}

    steps:
      - name: Set up kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 --decode > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config get-contexts

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Check Java microservice image availability
        run: |
          export KUBECONFIG=kubeconfig
          IMAGE_TAG=${{ needs.build-frontend.outputs.image-tag }}

          echo "üîç Checking Java microservice image availability"
          if docker manifest inspect "ghcr.io/medotarek73/java-microservice-api:$IMAGE_TAG" >/dev/null 2>&1; then
            echo "‚úÖ Java microservice image with tag $IMAGE_TAG found"
            echo "BACKEND_IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Java microservice image with tag $IMAGE_TAG not found, using latest"
            echo "BACKEND_IMAGE_TAG=latest" >> $GITHUB_ENV
          fi

      - name: Deploy Backend Service
        run: |
          export KUBECONFIG=kubeconfig
          NS=${{ needs.build-frontend.outputs.namespace }}

          echo "üöÄ Deploying Backend Service"

          # Delete existing deployment if it exists
          kubectl delete deployment backend-service -n $NS --ignore-not-found=true

          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend-service
            namespace: $NS
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: backend-service
            template:
              metadata:
                labels:
                  app: backend-service
              spec:
                containers:
                - name: backend-service
                  image: ghcr.io/medotarek73/java-microservice-api:$BACKEND_IMAGE_TAG
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8080
                  env:
                  - name: QUARKUS_HTTP_HOST
                    value: "0.0.0.0"
                  - name: QUARKUS_HTTP_PORT
                    value: "8080"
                imagePullSecrets:
                - name: ghcr-secret
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: backend-service
            namespace: $NS
          spec:
            selector:
              app: backend-service
            ports:
            - port: 8080
              targetPort: 8080
          EOF

          echo "‚úÖ Backend service deployed successfully"

      - name: Set output for comment job
        id: set-output
        run: |
          echo "backend-image-tag=$BACKEND_IMAGE_TAG" >> $GITHUB_OUTPUT

  comment-on-pr:
    needs: [build-frontend, deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            // Delete previous deployment comments
            for (const comment of comments) {
              if (comment.body.includes('üöÄ Review App Launched')) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id,
                });
              }
            }

            // Get deployment info
            const frontendImage = `ghcr.io/medotarek73/nextjs-monorepo:${{ needs.build-frontend.outputs.image-tag }}`;
            const backendImage = `ghcr.io/medotarek73/java-microservice-api:${{ needs.deploy-backend.outputs.backend-image-tag }}`;
            const namespace = '${{ needs.build-frontend.outputs.namespace }}';
            const url = `https://${namespace}.semibots.com`;

            // Determine backend image status
            const backendImageStatus = '${{ needs.deploy-backend.outputs.backend-image-tag }}' === '${{ needs.build-frontend.outputs.image-tag }}'
              ? 'Latest feature branch package deployed'
              : 'Using latest tag (feature branch package not found)';

            const commentBody = `## üöÄ Review App Launched

            **‚úÖ PR Preview Environment Successfully Deployed!**

            ### üì¶ Packages Deployed:
            - **Frontend Package:** \`${frontendImage}\`
            - **Backend Package:** \`${backendImage}\`

            ### üåê Review App Access:
            - **üîó Live URL:** ${url}
            - **üìÅ Kubernetes Namespace:** \`${namespace}\`

            ### üîÑ Package Status:
            - **Frontend:** ‚úÖ Latest feature branch package deployed
            - **Backend:**  ‚úÖ ${backendImageStatus}

            ### üìã Deployment Information:
            - **üë§ Triggered by:** ${{ github.actor }}
            - **üåø Frontend Branch:** \`${{ github.head_ref }}\`
            - **üåø Backend Branch:** \`${{ needs.deploy-backend.outputs.backend-image-tag }}\`
            - **üìù Commit:** \`${{ github.event.pull_request.head.sha }}\`
            - **‚è∞ Deployed at:** ${new Date().toISOString()}

            ---
            **üéâ Your review app is ready for testing!**`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody,
            });
